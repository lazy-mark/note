# 多线程引发的问题

## 安全性问题

### 原子性

### 可见性

## 上下文切换

Java 中的线程与 CPU 单核执行是一对一的，即单个处理器同一时间只能处理一个线程的执行；而 CPU 是通过时间片算法来执行任务的，不同的线程活跃状态不同，CPU 会在多个线程间切换执行，在切换时会保存上一个任务的状态，以便下次切换回这个任务时可以再加载到这个任务的状态，这种任务的保存到加载就是一次上下文切换。

线程数越多，带来的上下文切换越严重，上下文切换会带来 CPU 系统态使用率占用，这就是为什么当我们开启大量线程，系统反而更慢的原因。



如何减少上下文切换？

- 减少锁等待：锁等待意味着，线程频繁在活跃与等待状态之间切换，增加上下文切换，锁等待是由对同一份资源竞争激烈引起的，在一些场景我们可以用一些手段减轻锁竞争，比如数据分片或者数据快照等方式；
- CAS 算法：利用 Compare and Swap, 即比较再交换可以避免加锁；
- 使用合适的线程数或者协程：使用合适的线程数而不是越多越好，在 CPU 密集的系统中，比如我们倾向于启动最多 2 倍处理器核心数量的线程；协程由于天然在单线程实现多任务的调度，所以协程实际上避免了上下文切换；

## 活跃性问题

当某些操作迟迟得不到执行时，就被认为是产生了活跃性问题，活跃性分为两类，一类是死锁，一类是饥饿。

死锁是最常见的活跃性问题，除此之外还有饥饿、活锁。在多线程开发中，我们要避免线程安全问题，势必要对共享的数据资源进行加锁，而加锁处理不当即会带来死锁。

当线程由于无法访它所需的资源而不能继续执行时，就发生了饥饿。

![image-20210726233808629](asserts/image-20210726233808629.png)

避免死锁：

- 获取锁的顺序是固定的；

