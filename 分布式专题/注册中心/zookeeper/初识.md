# ZK

## 什么是Zookeeper

在分布式环境中，存在着大量的服务，服务与服务之间难以做到彼此协调，也不便于开发人员对服务进行维护管理，而 Zookeeper 使用它简单的结构和 API ，协调服务与服务之间的关系，让开发人员专注于应用程序的核心业务逻辑，更方便的对应用程序的服务进行管理维护。Zookeeper也因此叫做分布式协调者。

## Zookeeper应用

### 服务注册与发现

当我们的分布式系统增加了一个服务，我们只需要利用 Znode 和 Watcher，让它注册到 Zookeeper 中，我们就可以很方便的对这个服务进行管理；

### 分布式锁

为了防止在分布式环境下，服务中多个进程之间互相干扰，我们可以用 Zookeeper 的临时顺序节点实现分布式锁，对这些进程进行调度，让它们顺序执行；

### 配置管理

我们可以把核心的配置文件交给 Zookeeper 管理。当我们修改配置文件时，Zookeeper 就会把配置文件的信息同步到集群中的所有节点中去。

## Zookeeper特点

1. 在分布式环境下，Zookeeper 的部署方式为一主（ Leader ）多从（ Follower ）的集群方式，只要半数以上的节点（包括 Leader 节点）存活，Zookeeper 集群就能正常服务。就算是 Leader 节点挂掉了，Zookeeper 也会进行崩溃恢复，因此 Zookeeper 集群本身是高可用的；
2. Zookeeper 集群的数据具有全局一致性。也就是说，无论客户端连接到 Zookeeper 集群的哪一个从节点，获取的数据都是一致的；
3. 在 Zookeeper 集群节点进行数据同步更新时，要么全部成功，要么全部失败。所以 Zookeeper 的数据更新具有原子性；
4. 在同一个客户端对 Zookeeper 节点进行更新请求操作时，会根据发送的顺序依次去执行；
5. 由于 Zookeeper 能存储的数据量非常小，所以数据的同步更新也会非常快。也就可以说在一定时间段内，客户端获取的数据是实时的。



## Zookeeper应用领域与其他技术比较

### 服务注册与发现

#### Zookeeper与Eureka

Eureka 是 Spring Cloud 微服务架构的分布式注册中心。

|    分布式注册中心     |                             优点                             |                             缺点                             |
| :-------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| Zookeeper （保证 CP） |    新的服务注册时会同步到其他节点，保证了节点数据的一致性    | 为了保证一致性，在 Leader 选举阶段服务不能注册，失去了可用性 |
|  Eureka （保证 AP）   | Eureka 的各个节点是平等的，只要有一个节点存在，就可以提供服务 |  新服务注册时，不会把数据同步到其他节点上，失去了数据一致性  |



### 分布式锁

#### Zookeeper与Redis

除了 Zookeeper 可以实现分布式锁之外，我们还可以使用高性能缓存技术 Redis 来实现，我们来比较一下它们的优缺点。

| 分布式锁  |                             优点                             |                             缺点                             |
| :-------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| Zookeeper | 1. 功能已经封装，实现简单 2. 有等待锁的队列，提升了抢锁的效率 |                    添加和删除节点性能较低                    |
|   Redis   |                   Set 和 Del 指令的性能高                    | 1. 实现较复杂，需要考虑超时、原子性、误删的情况 2. 没有等锁队列，只能通过客户端自旋来等锁，效率低下 |



## Zookeeper的数据模型

Zookeeper 数据模型的结构是基于节点的，我们把这种节点叫做 **Znode** 。

我们对节点的引用，必须书写全路径，也就是说必须要从根节点开始。在 Zookeeper 底层的实现中，把 Znode 的绝对路径作为 key ，Znode 本身作为 value 来保存的。使用绝对路径来查询也提高了 Zookeeper 的性能。



### Znode元素组成

Znode 节点中由 4 种元素组成。

- **data ：** Znode 存储的数据信息，这里的数据指用户保存的数据；
- **ACL ：** 对节点进行权限控制，记录了哪些用户或者哪些 IP 地址可以访问本节点；
- **child ：** 当前节点的子节点引用，通过这个节点来找到它的子节点；
- **stat ：** 包含 Znode 的各种元数据，比如事务 ID、版本号、时间戳、大小等 Znode 本身的数据。

Znode 的 data 元素存储的信息最大不能超过 1MB 。太大的数据会影响 Zookeeper 的同步性能。



### Znode的类型

Znode 的类型分为一下 4 种：

- **持久节点：** 持久节点是 Zookeeper 的默认节点，持久节点被创建后会一直存在，除非进行手动删除；
- **持久顺序节点：** 持久顺序节点是在持久节点的基础上，增加了顺序性。也就是说，持久顺序节点被创建时，会根据创建的时间进行编号，根据编号我们就可以判断它们的顺序；
- **临时节点：** 临时节点与持久节点的特点相反，临时节点被创建之后，如果与创建它的客户端断开连接，临时节点就会被销毁；
- **临时顺序节点：** 临时顺序节点就是在临时节点的基础上，增加了顺序性。



### Znode的实际应用

根据节点的类型以及它们的特点，我们可以实现以下功能：

1. 我们可以使用**临时节点**来实现服务注册与发现。在某个服务注册到 ZooKeeper 时，我们可以让这个这个服务创建一个临时节点，并把它的访问信息交给到 Zookeeper 维护。当这个服务与 Zookeeper 断开连接时，这个临时节点就会被销毁，这时 Zookeeper 发现这个服务离线了，就会移除它的访问地址，避免出现 404 的情况。我们也可以手动删除某个临时节点让相对应的服务下线；
2. 当我们有大量的服务时，一旦配置信息需要修改，会消耗我们大量的时间去每个服务中修改，而且还有可能会出错，这种情况我们就可以使用**持久节点**来保存全局的配置信息。当某个服务注册到 ZooKeeper 时，可以去保存配置信息的节点读取配置信息。当我们修改配置时，Zookeeper 会通知这些服务，服务就会重新去读取配置信息；
3. 我们可以使用**临时顺序节点**来实现**分布式锁**。当多个服务同时对一个资源进行修改时，会出现数据错误，所以我们要避免这种情况。我们这里采取的方式就是为这个资源加锁，想要获取这个资源的服务会创建一个临时顺序节点，根据它的顺序判断这个临时顺序节点是否为第一个，如果是第一个则成功获得锁，这时这个服务就可以对这个资源进行修改了。完成操作后或者这个服务断线了都会删除这个节点，也就是释放了锁。后面的服务会根据它创建的临时顺序节点的顺序来依次对资源进行操作。



### 操作Znode

- 创建节点：create
- 删除节点：delete
- 获取一个节点的数据：get
- 设置一个节点的数据：set
- 获取子节点：ls

在使用这些命令操作节点时，后面的节点必须是全路径引用。